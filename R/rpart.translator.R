#' RPart Translator
#'
#' This function formats a "rpart" decision tree model into a table of rules
#' and sub-rules.
#'
#' Before running this function, a "rpart" model must be generated using the
#' "rpart" package. That model and the data used to generate the model will be
#' passed in as parameters to create the table of rules and sub-rules, with
#' accompanying volume statistics.
#'
#' @param model The model generated by "rpart" containing the decision tree. Only classification models are supported.
#' @param data The data that was used to create the "rpart" model.
#' @return A data table of rules and sub-rules. Each column is listed below:
#' \item{Rule}{ Identifier for an overall rule that many sub-rules roll up
#' into. A rule requires all sub-rules to be applied to a data set. }
#' \item{Subrule}{ Identifier for a single piece of a larger rule. There can be
#' many sub-rules that make up a single rule. }
#' \item{Variable}{ Column name of
#' the data set that the sub-rule is defining. }
#' \item{Operator}{ Mathematical
#' operator defining how a column and value interact. Can be =, >=, <=, >, or
#' <. A sub-rule with many "=" operators are treated as "OR" staements. }
#' \item{Value}{ Value of the column (defined in the Variable field) that the
#' sub-rule is defining. }
#' \item{TotalVolume}{ Number of records that the sub-rule
#' captures when all sub-rules are applied for a single rule. }
#' \item{TargetPredicted}{ The target value the sub-rule is trying to capture. }
#' \item{TargetPredictedVolume}{ Number of target records that the sub-rule
#' captures when all sub-rules are applied for a single rule. }
#' @references Terry Therneau and Beth Atkinson (2018) Authors and
#' maintainers of rpart version 4.1-13. Brian Ripley (1999-2017) Producer of
#' the initial R port and maintainer.
#' @examples
#'
#' library(rpart)
#' library(rpart.translator)
#'
#' fit <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis)
#'
#' dataTable <- rpart.translator(fit, kyphosis)
#'
#' @import rpart
#' @import rpart.utils
#' @import dplyr
#' @import splitstackshape
#' @importFrom data.table data.table
#' @importFrom reshape melt
#' @importFrom rlang .data
#' @export
#'
rpart.translator <- function(model, data) {

  # Name of the script being run for error check output messages.
  scriptName = 'rpart.translator'

  # Variable checks
  tryCatch(
    {
      if (is.null(model)){
        stop('The \"model\" variable was not supplied.')
      }

      if(!inherits(model, "rpart")){
        stop("The \"model\" variable is not a legitimate \"rpart\" object.")
      }

      if (is.null(data)){
        stop('The \"data\" variable was not supplied.')
      }

      if (!is.data.frame(data)){
        stop('The \"data\" variable is not a data frame.')
      }

      if (model$method != "class"){
        stop('The \"model\" variable was not run with method = \"class\". Only classification models are supported by rpart.translator.')
      }

    },
    error = function(e){
      stop(paste(scriptName, '- ERROR - VariableCheck:', e))
    }
  )

  # Parse rules
  tryCatch(
    {
      # Get rules
      rule_df <- rpart.rules.table(model) %>%
        filter(.data$Leaf==TRUE) %>%
        group_by(.data$Rule) %>%
        summarise(Subrules = paste(.data$Subrule, collapse=","))

      # Break apart the dplyer statements above
      rulesTable <- rpart.rules.table(model)

      rulesTableFilter <- filter(rulesTable, .data$Leaf==TRUE)

      rulesTableGroupBy <- group_by(rulesTableFilter, .data$Rule)

      # rulesTableGroupBy looks like the table that we need, add subrules
      subrules <- rpart.subrules.table(model)

      subrules <- subrules %>%
        mutate(Subrule = as.character(Subrule))

      rulesTableGroupBy <- rulesTableGroupBy %>%
        mutate(Subrule = as.character(Subrule))

      rulesTableWithSubRules <- left_join(rulesTableGroupBy, subrules, by="Subrule")

    },
    error = function(e){
      stop(paste(scriptName, '- ERROR - ParseRules:', e))
    }
  )

  # Add operators
  tryCatch(
    {
      # Add operator and condense greater/less than fields into single Value column
      rulesTableWithSubRules <- rulesTableWithSubRules %>%
        mutate(
          Operator = case_when(
            is.na(Less) & is.na(Greater) & !is.na(Value) ~ "=",
            is.na(Less) & !is.na(Greater) & is.na(Value) ~ ">",
            !is.na(Less) & is.na(Greater) & is.na(Value) ~ "<",
            is.na(Less) & !is.na(Greater) & !is.na(Value) ~ ">=",
            !is.na(Less) & is.na(Greater) & !is.na(Value) ~ "<=",
            TRUE ~ "other"
          )
        )

      rulesTableWithSubRules$Value <- ifelse(is.na(rulesTableWithSubRules$Value),
                                             ifelse(is.na(rulesTableWithSubRules$Less),
                                                    as.character(rulesTableWithSubRules$Greater),
                                                    as.character(rulesTableWithSubRules$Less)
                                             ),
                                             as.character(rulesTableWithSubRules$Value)
      )

      rulesTableWithSubRules$Value <- as.factor(rulesTableWithSubRules$Value)

      rulesTableWithSubRules$Less <- NULL

      rulesTableWithSubRules$Greater <- NULL

    },
    error = function(e){
      stop(paste(scriptName, '- ERROR - OperatorCondensing:', e))
    }
  )

  # Volume counting
  tryCatch(
    {
      # Get columns used in fitted model
      targetColumnName <- attributes(attributes(model$terms)$dataClasses)$names[1]
      columnsUsed <- c(levels(unique(rulesTableWithSubRules$Variable)), targetColumnName)

      # Get volumes from dataset
      rule_df <- rule_df %>%
        mutate(Rule = as.character(Rule))

      dataRules <- data[columnsUsed] %>%
        mutate(Rule = row.names(model$frame)[model$where]) %>%
        left_join(rule_df, by="Rule")

      # Convert all columns to the same data type before unpivoting
      dataRules_Convert <- dataRules
      dataRules_Convert[sapply(dataRules_Convert, is.numeric)] <- lapply(dataRules_Convert[sapply(dataRules_Convert, is.numeric)], as.character)
      dataRules_Convert[sapply(dataRules_Convert, is.factor)] <- lapply(dataRules_Convert[sapply(dataRules_Convert, is.factor)], as.character)

      # Unpivot data frame
      dataRulesUnPivot <- melt(dataRules_Convert, id = c("Rule","Subrules", targetColumnName))

      # Split CSV column Subrules, then unpivot.
      dataCSW <- cSplit(dataRulesUnPivot, splitCols = "Subrules", sep = ",", direction = "long")

      # Count records, and Group By Rule, Subrules, Variable, Value. Also, reduce data set size for next steps.
      colnames(dataCSW)[colnames(dataCSW)==targetColumnName] <- "TargetActual"

      if(model$method == "class"){
        model$frame$TargetPredicted <- attributes(model)$ylevels[model$frame$yval]
      }else {
        model$frame$TargetPredicted <- model$frame$y
      }

      model$frame$Rule <- as.character(rownames(model$frame))

      dataCSW <- left_join(dataCSW, model$frame[c("Rule", "TargetPredicted")], by="Rule")

      dataGrouped <- count(dataCSW, .data$Rule, .data$Subrules, .data$variable, .data$value, .data$TargetPredicted)

      colnames(dataGrouped)[colnames(dataGrouped)=="n"] <- "TotalVolume"

      targetActualCount <- count(filter(dataCSW, .data$TargetActual == .data$TargetPredicted), .data$Rule, .data$Subrules, .data$variable, .data$value, .data$TargetPredicted)

      colnames(targetActualCount)[colnames(targetActualCount)=="n"] <- "TargetPredictedVolume"

      dataGrouped <- left_join(dataGrouped, targetActualCount, by = c("Rule", "Subrules", "variable", "value", "TargetPredicted"))

      dataGrouped$TargetPredictedVolume[is.na(dataGrouped$TargetPredictedVolume)] <- 0

    },
    error = function(e){
      stop(paste(scriptName, '- ERROR - VolumeCounting:', e))
    }
  )

  # Rule joining
  tryCatch(
    {
      # Left Join counted data to the rulesTableWithSubRules, need to rename columns for join to work.
      names(dataGrouped)[names(dataGrouped) == 'Subrules'] <- 'Subrule'
      names(dataGrouped)[names(dataGrouped) == 'variable'] <- 'Variable'
      names(dataGrouped)[names(dataGrouped) == 'value'] <- 'Value'

      # Join each type of operator for counting
      # Set variables equal to NULL to deal with package checks not knowing the context of columns/functions being used in data.table
      . = NULL
      .EACHI = NULL
      Rule = NULL
      Subrule = NULL
      Variable = NULL
      Value = NULL
      Operator = NULL
      TotalVolume = NULL
      TargetPredictedVolume = NULL
      TargetPredicted = NULL

      # = join
      rulesTableCounted <- data.table(dataGrouped)[data.table(rulesTableWithSubRules)[Operator == "="], on = c(Rule = "Rule", Subrule = "Subrule", Variable = "Variable", Value = "Value")][, c("Rule", "Subrule", "Variable", "Operator", "Value", "TotalVolume", "TargetPredicted", "TargetPredictedVolume")]

      # Prep columns for numeric comparisons
      dataGrouped$Value = as.numeric(as.character(dataGrouped$Value))
      rulesTableWithSubRules$Value = as.numeric(as.character(rulesTableWithSubRules$Value))

      # >= join
      rulesTableCounted <- rbind(rulesTableCounted, data.table(dataGrouped)[data.table(rulesTableWithSubRules)[Operator == ">="], on=.(Rule == Rule, Subrule == Subrule, Variable == Variable, Value >= Value), .(TotalVolume = sum(TotalVolume), TargetPredictedVolume = sum(TargetPredictedVolume), Operator = max(">="), TargetPredicted = if(length(TargetPredicted)>0) max(TargetPredicted) else -Inf), by=.EACHI][, c("Rule", "Subrule", "Variable", "Operator", "Value", "TotalVolume", "TargetPredicted", "TargetPredictedVolume")])

      # > join
      rulesTableCounted <- rbind(rulesTableCounted, data.table(dataGrouped)[data.table(rulesTableWithSubRules)[Operator == ">"], on=.(Rule == Rule, Subrule == Subrule, Variable == Variable, Value > Value), .(TotalVolume = sum(TotalVolume), TargetPredictedVolume = sum(TargetPredictedVolume), Operator = max(">"), TargetPredicted = if(length(TargetPredicted)>0) max(TargetPredicted) else -Inf), by=.EACHI][, c("Rule", "Subrule", "Variable", "Operator", "Value", "TotalVolume", "TargetPredicted", "TargetPredictedVolume")])

      # <= join
      rulesTableCounted <- rbind(rulesTableCounted, data.table(dataGrouped)[data.table(rulesTableWithSubRules)[Operator == "<="], on=.(Rule == Rule, Subrule == Subrule, Variable == Variable, Value <= Value), .(TotalVolume = sum(TotalVolume), TargetPredictedVolume = sum(TargetPredictedVolume), Operator = max("<="), TargetPredicted = if(length(TargetPredicted)>0) max(TargetPredicted) else -Inf), by=.EACHI][, c("Rule", "Subrule", "Variable", "Operator", "Value", "TotalVolume", "TargetPredicted", "TargetPredictedVolume")])

      # < join
      rulesTableCounted <- rbind(rulesTableCounted, data.table(dataGrouped)[data.table(rulesTableWithSubRules)[Operator == "<"], on=.(Rule == Rule, Subrule == Subrule, Variable == Variable, Value < Value), .(TotalVolume = sum(TotalVolume), TargetPredictedVolume = sum(TargetPredictedVolume), Operator = max("<"), TargetPredicted = if(length(TargetPredicted)>0) max(TargetPredicted) else -Inf), by=.EACHI][, c("Rule", "Subrule", "Variable", "Operator", "Value", "TotalVolume", "TargetPredicted", "TargetPredictedVolume")])

      # Remove rules with 0 counts
      rulesTableCounted <- rulesTableCounted[is.na(TotalVolume) == FALSE]

    },
    error = function(e){
      stop(paste(scriptName, '- ERROR - RuleJoining:', e))
    }
  )

  # Return table
  return(rulesTableCounted)

}
